# app.py
import time
from datetime import datetime
import hashlib

import streamlit as st
import pandas as pd
import numpy as np
import gspread
from google.oauth2.service_account import Credentials

# =========================
# PAGE CONFIG
# =========================
st.set_page_config(page_title="H·ªá th·ªëng tr·∫Øc nghi·ªám tr·ª±c tuy·∫øn", layout="wide")

def render_banner():
    st.markdown(
        (
            "<div style='padding:10px 16px;border-radius:10px;"
            "background:#0f172a;color:#1e90ff;font-weight:600;"
            "display:flex;align-items:center;gap:10px'>"
            "H·ªá th·ªëng tr·∫Øc nghi·ªám tr·ª±c tuy·∫øn"
            "</div>"
        ),
        unsafe_allow_html=True,
    )

# =========================
# SECRETS HELPERS
# =========================
def sget(key, default=None):
    """Get secret by priority: top-level ‚Üí [app] ‚Üí default."""
    if key in st.secrets:
        return st.secrets[key]
    if "app" in st.secrets and key in st.secrets["app"]:
        return st.secrets["app"][key]
    return default

def srequire(key):
    val = sget(key)
    if val in (None, ""):
        st.error(f"‚ùå Thi·∫øu kh√≥a secrets: {key}. V√†o Manage app ‚Üí Settings ‚Üí Secrets ƒë·ªÉ b·ªï sung.")
        st.stop()
    return val

# App config
QUIZ_ID        = sget("QUIZ_ID", "PSY36")
TIME_LIMIT_MIN = int(sget("TIME_LIMIT_MIN", 20))
TEACHER_USER   = str(sget("TEACHER_USER", "teacher")).strip()
TEACHER_PASS   = str(sget("TEACHER_PASS", "teacher123")).strip()

# Google Sheets config
QUESTIONS_SPREADSHEET_ID = srequire("QUESTIONS_SPREADSHEET_ID")
QUESTIONS_SHEET_NAME     = sget("QUESTIONS_SHEET_NAME", "Question")

RESPONSES_SPREADSHEET_ID = srequire("RESPONSES_SPREADSHEET_ID")

# =========================
# GOOGLE SHEETS HELPERS
# =========================
def get_gspread_client():
    """Authorize gspread with Sheets + Drive scopes."""
    scopes = [
        "https://www.googleapis.com/auth/spreadsheets",
        "https://www.googleapis.com/auth/drive",
    ]
    sa = st.secrets.get("gcp_service_account")
    if not sa or "client_email" not in sa or "private_key" not in sa:
        st.error("‚ùå Thi·∫øu ho·∫∑c sai kh·ªëi [gcp_service_account] trong Secrets.")
        st.stop()
    creds = Credentials.from_service_account_info(sa, scopes=scopes)
    return gspread.authorize(creds)

def diagnose_gsheet_access(spreadsheet_id: str, sheet_name: str):
    """Show a friendly how-to when permission or ID is wrong."""
    sa_email = st.secrets["gcp_service_account"].get("client_email", "(unknown)")
    st.error("Kh√¥ng truy c·∫≠p ƒë∆∞·ª£c Google Sheet (PermissionError/APIError).")
    st.info(
        "üîß C√°ch s·ª≠a:\n"
        f"1) M·ªü file Google Sheet ID: `{spreadsheet_id}`\n"
        f"2) Share cho service account: **{sa_email}** ‚Üí quy·ªÅn **Editor**\n"
        f"3) T√™n worksheet ƒë√∫ng: **{sheet_name}**\n"
        "4) Save ‚Üí Rerun/Restart app."
    )

@st.cache_data(ttl=300)
def load_questions_df():
    """ƒê·ªçc ng√¢n h√†ng c√¢u h·ªèi Likert t·ª´ worksheet Question, l·ªçc theo QUIZ_ID n·∫øu c√≥."""
    gc = get_gspread_client()
    try:
        sh = gc.open_by_key(QUESTIONS_SPREADSHEET_ID)
    except Exception:
        diagnose_gsheet_access(QUESTIONS_SPREADSHEET_ID, QUESTIONS_SHEET_NAME)
        st.stop()

    try:
        ws = sh.worksheet(QUESTIONS_SHEET_NAME)
    except gspread.WorksheetNotFound:
        st.error(f"Kh√¥ng th·∫•y worksheet t√™n **{QUESTIONS_SHEET_NAME}**.")
        st.stop()

    df = pd.DataFrame(ws.get_all_records())
    if df.empty:
        st.warning("Worksheet c√¢u h·ªèi tr·ªëng.")
        return df

    if "q_index" not in df.columns:
        df["q_index"] = range(1, len(df) + 1)
    if "quiz_id" in df.columns:
        df = df[df["quiz_id"].astype(str).str.strip() == str(QUIZ_ID)].copy()

    df = df.sort_values("q_index")
    return df

def _col_idx_to_letter(idx_1based: int) -> str:
    """1 -> A, 26 -> Z, 27 -> AA ..."""
    n = idx_1based
    s = ""
    while n > 0:
        n, r = divmod(n - 1, 26)
        s = chr(65 + r) + s
    return s

# =========================
# CLASS / ROSTER HELPERS (ƒëa l·ªõp, whitelist t·ª´ roster g·ªëc)
# =========================
CLASS_ROSTERS = ["D25A", "D25C"]  # m·ªü r·ªông khi c·∫ßn
MCQ_QUESTIONS_SHEET_NAME = sget("MCQ_QUESTIONS_SHEET_NAME", "MCQ_Questions")

def open_roster_ws(class_code: str):
    """M·ªü sheet danh s√°ch g·ªëc (whitelist) theo l·ªõp, v√≠ d·ª• 'D25A' ho·∫∑c 'D25C'."""
    class_code = class_code.strip()
    gc = get_gspread_client()
    try:
        sh = gc.open_by_key(RESPONSES_SPREADSHEET_ID)
        ws = sh.worksheet(class_code)  # roster g·ªëc
    except Exception as e:
        st.error(f"Kh√¥ng m·ªü ƒë∆∞·ª£c roster l·ªõp '{class_code}': {e}")
        st.stop()
    return ws

@st.cache_data(ttl=120)
def load_whitelist_students_by_class(class_code: str):
    """
    ƒê·ªçc whitelist t·ª´ sheet l·ªõp g·ªëc (D25A/D25C). Y√™u c·∫ßu c·ªôt:
    STT | MSSV | H·ªç v√† t√™n | NTNS | t·ªï
    Tr·∫£ v·ªÅ dict {MSSV: {'name':..., 'dob':..., 'to':...}}
    """
    ws = open_roster_ws(class_code)
    rows = ws.get_all_values()
    if not rows or len(rows) < 2:
        return {}
    header = [h.strip() for h in rows[0]]
    data = rows[1:]

    def find_idx(names):
        for n in names:
            if n in header:
                return header.index(n)
        return None

    idx_mssv = find_idx(["MSSV", "mssv"])
    idx_name = find_idx(["H·ªç v√† t√™n", "Ho va ten", "H·ªç v√† T√™n", "Ho va Ten"])
    idx_dob  = find_idx(["NTNS", "ntns", "Ng√†y sinh", "DOB"])
    idx_to   = find_idx(["t·ªï", "To", "to"])

    if idx_mssv is None or idx_name is None:
        st.error("Roster l·ªõp thi·∫øu c·ªôt 'MSSV' ho·∫∑c 'H·ªç v√† t√™n'.")
        st.stop()

    wl = {}
    for r in data:
        if len(r) <= idx_mssv:
            continue
        mssv = r[idx_mssv].strip()
        if not mssv:
            continue
        wl[mssv] = {
            "name": r[idx_name].strip() if len(r) > idx_name else "",
            "dob":  r[idx_dob].strip() if (idx_dob is not None and len(r) > idx_dob) else "",
            "to":   r[idx_to].strip()  if (idx_to is not None and len(r) > idx_to)  else "",
        }
    return wl

def _ensure_header(ws, base_cols, tail_cols):
    """ƒê·∫£m b·∫£o header c√≥ ƒë·ªß c√°c c·ªôt trong base_cols + tail_cols theo th·ª© t·ª±, kh√¥ng x√≥a d·ªØ li·ªáu c≈©."""
    header = ws.row_values(1)
    changed = False
    for c in base_cols + tail_cols:
        if c not in header:
            header.append(c); changed = True
    if changed or not header:
        ws.update("A1", [header])
    return header

def open_likert_response_ws_for_class(class_code: str):
    """M·ªü/t·∫°o sheet k·∫øt qu·∫£ Likert theo l·ªõp: 'LikertD25A'..."""
    gc = get_gspread_client()
    name = f"Likert{class_code.strip()}"
    try:
        sh = gc.open_by_key(RESPONSES_SPREADSHEET_ID)
        try:
            ws = sh.worksheet(name)
        except gspread.WorksheetNotFound:
            ws = sh.add_worksheet(title=name, rows=2000, cols=80)
    except Exception as e:
        st.error(f"Kh√¥ng m·ªü ƒë∆∞·ª£c sheet '{name}': {e}")
        st.stop()
    base = ["TT", "MSSV", "H·ªç v√† T√™n", "NTNS", "t·ªï"]
    qcols = [str(i) for i in range(1, 37)]
    tail = ["submitted_at", "quiz_id", "class"]
    _ensure_header(ws, base, qcols + tail)
    return ws

def open_mcq_response_ws_for_class(class_code: str, n_questions: int):
    """M·ªü/t·∫°o sheet k·∫øt qu·∫£ MCQ theo l·ªõp: 'MCQD25A'... (t·ª± th√™m 1..N)."""
    gc = get_gspread_client()
    name = f"MCQ{class_code.strip()}"
    try:
        sh = gc.open_by_key(RESPONSES_SPREADSHEET_ID)
        try:
            ws = sh.worksheet(name)
        except gspread.WorksheetNotFound:
            ws = sh.add_worksheet(title=name, rows=2000, cols=200)
    except Exception as e:
        st.error(f"Kh√¥ng m·ªü ƒë∆∞·ª£c sheet '{name}': {e}")
        st.stop()
    base = ["TT", "MSSV", "H·ªç v√† T√™n", "NTNS", "t·ªï"]
    qcols = [str(i) for i in range(1, n_questions + 1)]
    tail = ["score", "submitted_at", "quiz_id", "class"]
    _ensure_header(ws, base, qcols + tail)
    return ws

def attempt_exists(ws, header, mssv: str) -> bool:
    """Ki·ªÉm tra SV ƒë√£ n·ªôp (ƒë√£ c√≥ submitted_at ho·∫∑c c√≥ √≠t nh·∫•t 1 c√¢u tr·∫£ l·ªùi)."""
    try:
        col_mssv = header.index("MSSV")
    except ValueError:
        return False
    rows = ws.get_all_values()[1:]
    for r in rows:
        if len(r) > col_mssv and r[col_mssv].strip() == mssv.strip():
            if "submitted_at" in header:
                c = header.index("submitted_at")
                if len(r) > c and r[c].strip():
                    return True
            for c_name in header:
                if c_name.isdigit():
                    c_idx = header.index(c_name)
                    if len(r) > c_idx and r[c_idx].strip():
                        return True
    return False

# =========================
# LOAD QUESTION BANKS
# =========================
@st.cache_data(ttl=300)
def load_mcq_questions_df():
    """ƒê·ªçc ng√¢n h√†ng MCQ t·ª´ worksheet MCQ_Questions."""
    gc = get_gspread_client()
    try:
        sh = gc.open_by_key(QUESTIONS_SPREADSHEET_ID)
        ws = sh.worksheet(MCQ_QUESTIONS_SHEET_NAME)
    except Exception:
        st.error(f"Kh√¥ng truy c·∫≠p ƒë∆∞·ª£c MCQ_Questions (sheet '{MCQ_QUESTIONS_SHEET_NAME}').")
        st.stop()

    df = pd.DataFrame(ws.get_all_records())
    if df.empty:
        st.warning("Worksheet MCQ_Questions tr·ªëng.")
        return df

    if "q_index" not in df.columns:
        df["q_index"] = range(1, len(df) + 1)
    if "quiz_id" in df.columns:
        df = df[df["quiz_id"].astype(str).str.strip() == str(QUIZ_ID)].copy()
    df = df.sort_values("q_index")
    return df

# =========================
# SHUFFLE STABLE PER STUDENT
# =========================
def stable_perm(n: int, key: str) -> list:
    """Sinh ho√°n v·ªã c·ªë ƒë·ªãnh cho m·ªói SV d·ª±a tr√™n hash(MSSV + H·ªç t√™n + QUIZ_ID)."""
    h = hashlib.sha256(key.encode("utf-8")).digest()
    rng_seed = int.from_bytes(h[:8], "big")
    rng = np.random.default_rng(rng_seed)
    arr = np.arange(n)
    rng.shuffle(arr)
    return arr.tolist()

def _option_perm_for_student(mssv: str, qidx: int):
    """Sinh ho√°n v·ªã 4 ƒë√°p √°n theo t·ª´ng SV cho m·ªói q_index."""
    key = f"MCQ|{QUIZ_ID}|{mssv}|{qidx}"
    h = hashlib.sha256(key.encode("utf-8")).digest()
    seed = int.from_bytes(h[:8], "big")
    rng = np.random.default_rng(seed)
    perm = np.arange(4)
    rng.shuffle(perm)
    return perm.tolist()

# =========================
# STUDENT EXAM ‚Äî COMMON STATE
# =========================
def init_exam_state():
    st.session_state.setdefault("sv_mssv", "")
    st.session_state.setdefault("sv_hoten", "")
    st.session_state.setdefault("sv_class", "")
    st.session_state.setdefault("sv_started", False)
    st.session_state.setdefault("sv_start_time", None)
    st.session_state.setdefault("sv_answers", {})      # {q_index -> 1..5}
    st.session_state.setdefault("sv_order", [])        # ho√°n v·ªã c√¢u h·ªèi
    st.session_state.setdefault("sv_cursor", 0)        # index ƒëang hi·ªÉn th·ªã
    st.session_state.setdefault("sv_allow", False)     # ƒë√£ ƒë·∫≠u whitelist ch∆∞a
    st.session_state.setdefault("mcq_cursor", 0)
    st.session_state.setdefault("mcq_answers", {})     # {q_index: 'A'..'D'}

def student_gate() -> bool:
    """
    C·ªïng ƒëƒÉng nh·∫≠p SV d√πng chung cho c·∫£ Likert v√† MCQ.
    Tr·∫£ v·ªÅ True n·∫øu ƒë√£ pass whitelist & set state (sv_allow=True).
    """
    init_exam_state()

    if st.session_state.get("sv_allow"):
        return True

    with st.form("sv_login_unified"):
        col0, col1, col2 = st.columns([1,1,2])
        with col0:
            class_code = st.selectbox("L·ªõp", options=CLASS_ROSTERS, index=0)
        with col1:
            mssv = st.text_input("MSSV", placeholder="VD: 2112345")
        with col2:
            hoten = st.text_input("H·ªç v√† T√™n", placeholder="VD: Nguy·ªÖn VƒÉn A")
        agree = st.checkbox("T√¥i x√°c nh·∫≠n th√¥ng tin tr√™n l√† ƒë√∫ng.")
        submitted = st.form_submit_button("ƒêƒÉng nh·∫≠p")

    if submitted:
        if not mssv or not hoten:
            st.error("Vui l√≤ng nh·∫≠p MSSV v√† H·ªç & T√™n.")
            return False
        if not agree:
            st.error("Vui l√≤ng t√≠ch x√°c nh·∫≠n.")
            return False

        # check whitelist l·ªõp
        wl = load_whitelist_students_by_class(class_code)
        if mssv.strip() not in wl:
            st.error(f"MSSV kh√¥ng n·∫±m trong l·ªõp {class_code}.")
            return False

        st.session_state["sv_class"] = class_code.strip()
        st.session_state["sv_mssv"] = mssv.strip()
        st.session_state["sv_hoten"] = hoten.strip()
        st.session_state["sv_allow"] = True
        st.success("ƒêƒÉng nh·∫≠p th√†nh c√¥ng.")
        st.rerun()

    st.info("Vui l√≤ng ƒëƒÉng nh·∫≠p ƒë·ªÉ ch·ªçn lo·∫°i tr·∫Øc nghi·ªám.")
    return False

# =========================
# STUDENT EXAM ‚Äî LIKERT
# =========================
def start_exam(mssv, hoten, n_questions):
    st.session_state["sv_mssv"] = mssv.strip()
    st.session_state["sv_hoten"] = hoten.strip()
    st.session_state["sv_started"] = True
    st.session_state["sv_start_time"] = time.time()
    key = f"{QUIZ_ID}|{mssv}|{hoten}"
    st.session_state["sv_order"] = stable_perm(n_questions, key)
    st.session_state["sv_cursor"] = 0
    st.session_state["sv_answers"] = {}

def remaining_seconds():
    if not st.session_state.get("sv_started"):
        return TIME_LIMIT_MIN * 60
    spent = time.time() - st.session_state["sv_start_time"]
    remain = max(0, int(TIME_LIMIT_MIN * 60 - spent))
    return remain

def render_timer():
    rem = remaining_seconds()
    mins = rem // 60
    secs = rem % 60
    st.markdown(f"‚è≥ **Th·ªùi gian c√≤n l·∫°i:** {mins:02d}:{secs:02d}")

def likert36_exam():
    if not st.session_state.get("sv_allow"):
        st.info("B·∫°n ch∆∞a ƒëƒÉng nh·∫≠p.")
        return

    df = load_questions_df()
    n_questions = len(df)
    st.success(f"ƒê·ªÅ {QUIZ_ID} ‚Äî {n_questions} c√¢u (Likert 1..5)")

    # N·∫øu ch∆∞a start -> kh·ªüi t·∫°o
    if not st.session_state.get("sv_started"):
        start_exam(st.session_state["sv_mssv"], st.session_state["sv_hoten"], n_questions)

    # Ch·∫∑n l√†m l·∫°i tr∆∞·ªõc khi l√†m (n·∫øu ƒë√£ c√≥ b√†i ·ªü sheet l·ªõp)
    class_code = st.session_state.get("sv_class", "")
    ws = open_likert_response_ws_for_class(class_code)
    header = ws.row_values(1)
    if attempt_exists(ws, header, st.session_state["sv_mssv"]):
        st.error("B·∫°n ƒë√£ n·ªôp b√†i Likert tr∆∞·ªõc ƒë√≥. Ch·ªâ ƒë∆∞·ª£c l√†m 1 l·∫ßn.")
        return

    # ƒêang l√†m b√†i
    render_timer()
    if remaining_seconds() <= 0:
        st.warning("‚è±Ô∏è H·∫øt th·ªùi gian ‚Äî h·ªá th·ªëng s·∫Ω n·ªôp b√†i v·ªõi c√°c c√¢u ƒë√£ ch·ªçn.")
        do_submit(df)
        return

    order = st.session_state["sv_order"] or list(range(n_questions))
    cur = st.session_state["sv_cursor"]
    cur = max(0, min(cur, n_questions - 1))
    st.session_state["sv_cursor"] = cur

    row = df.iloc[order[cur]]
    qidx = int(row["q_index"])
    qtext = str(row.get("question", f"C√¢u {qidx}"))
    left_label = str(row.get("left_label", "Ho√†n to√†n kh√¥ng ƒë·ªìng √Ω"))
    right_label = str(row.get("right_label", "Ho√†n to√†n ƒë·ªìng √Ω"))

    st.markdown(f"### C√¢u {cur+1}/{n_questions}")
    st.write(qtext)

    current_val = st.session_state["sv_answers"].get(qidx, None)
    picked = st.radio(
        "Ch·ªçn m·ª©c ƒë·ªô:",
        options=[1, 2, 3, 4, 5],
        index=[1,2,3,4,5].index(current_val) if current_val in [1,2,3,4,5] else None,
        horizontal=True,
        key=f"radio_{qidx}"
    )
    if picked:
        st.session_state["sv_answers"][qidx] = int(picked)

    help_text = (
        "**G·ª£i √Ω m·ª©c ƒë·ªô:**\n"
        "- 1 = Ho√†n to√†n kh√¥ng ƒë·ªìng √Ω  \n"
        "- 2 = Kh√¥ng ƒë·ªìng √Ω  \n"
        "- 3 = Ph√¢n v√¢n / Trung l·∫≠p  \n"
        "- 4 = ƒê·ªìng √Ω  \n"
        "- 5 = Ho√†n to√†n ƒë·ªìng √Ω"
    )
    st.markdown(help_text)

    c1, c2, c3 = st.columns([1, 1, 1])
    with c1:
        if st.button("‚¨ÖÔ∏è C√¢u tr∆∞·ªõc", use_container_width=True, disabled=(cur == 0)):
            st.session_state["sv_cursor"] = max(0, cur - 1)
            st.rerun()
    with c2:
        if st.button("‚û°Ô∏è C√¢u sau", use_container_width=True, disabled=(cur == n_questions - 1)):
            st.session_state["sv_cursor"] = min(n_questions - 1, cur + 1)
            st.rerun()
    with c3:
        if st.button("üìù N·ªôp b√†i Likert", use_container_width=True):
            do_submit(df)

def do_submit(df_questions: pd.DataFrame):
    """N·ªôp b√†i Likert: ghi l√™n sheet Likert<CLASS> v√† ch·∫∑n l√†m l·∫°i."""
    mssv = st.session_state.get("sv_mssv", "").strip()
    hoten = st.session_state.get("sv_hoten", "").strip()
    class_code = st.session_state.get("sv_class", "").strip()
    answers = st.session_state.get("sv_answers", {})

    if not mssv or not hoten or not class_code:
        st.error("Thi·∫øu th√¥ng tin ƒëƒÉng nh·∫≠p.")
        return

    # map 1..36 theo q_index c·ªßa ƒë·ªÅ
    ans_map = {}
    if "q_index" in df_questions.columns:
        qindices = sorted(df_questions["q_index"].astype(int).tolist())
    else:
        qindices = list(range(1, 37))
    for q in qindices:
        ans_map[int(q)] = answers.get(int(q), "")

    try:
        ws = open_likert_response_ws_for_class(class_code)
        header = ws.row_values(1)

        if attempt_exists(ws, header, mssv):
            st.error("B·∫°n ƒë√£ n·ªôp b√†i Likert tr∆∞·ªõc ƒë√≥. Ch·ªâ ƒë∆∞·ª£c l√†m 1 l·∫ßn.")
            return

        rows = ws.get_all_values()[1:]
        col_mssv = header.index("MSSV")
        found_row = None
        for idx, r in enumerate(rows, start=2):
            if len(r) > col_mssv and r[col_mssv].strip() == mssv.strip():
                found_row = idx
                break
        if not found_row:
            found_row = len(rows) + 2
            # MSSV, h·ªç t√™n, class
            for col_name, value in {"MSSV": mssv, "H·ªç v√† T√™n": hoten, "class": class_code}.items():
                if col_name in header:
                    cidx = header.index(col_name) + 1
                    ws.update_acell(f"{_col_idx_to_letter(cidx)}{found_row}", value)
            # NTNS/t·ªï t·ª´ roster
            info = load_whitelist_students_by_class(class_code).get(mssv, {})
            for col_name, key in {"NTNS": "dob", "t·ªï": "to"}.items():
                if col_name in header and key in info and info[key]:
                    cidx = header.index(col_name) + 1
                    ws.update_acell(f"{_col_idx_to_letter(cidx)}{found_row}", info[key])

        now_iso = datetime.now().astimezone().isoformat(timespec="seconds")
        updates = []
        for i in range(1, 37):
            if str(i) in header:
                cidx = header.index(str(i)) + 1
                updates.append({"range": f"{_col_idx_to_letter(cidx)}{found_row}", "values": [[ans_map.get(i, "")]]})
        for col_name, value in {"submitted_at": now_iso, "quiz_id": QUIZ_ID, "class": class_code}.items():
            if col_name in header:
                cidx = header.index(col_name) + 1
                updates.append({"range": f"{_col_idx_to_letter(cidx)}{found_row}", "values": [[value]]})

        if updates:
            ws.batch_update(updates)

    except Exception as e:
        st.error(f"L·ªói ghi Responses Likert: {e}")
        return

    st.success("‚úÖ ƒê√£ n·ªôp b√†i Likert th√†nh c√¥ng!")
    for k in ["sv_started", "sv_start_time", "sv_answers", "sv_order", "sv_cursor"]:
        st.session_state.pop(k, None)

# =========================
# STUDENT EXAM ‚Äî MCQ
# =========================
def mcq_exam():
    """B√†i thi MCQ 4 l·ª±a ch·ªçn, tr·ªôn th·ª© t·ª± c√¢u & ƒë√°p √°n theo t·ª´ng SV, ghi sheet theo l·ªõp."""
    if not st.session_state.get("sv_allow"):
        st.info("B·∫°n ch∆∞a ƒëƒÉng nh·∫≠p.")
        return

    df = load_mcq_questions_df()
    if df.empty:
        st.warning("Ch∆∞a c√≥ c√¢u h·ªèi MCQ.")
        return

    mssv = st.session_state.get("sv_mssv", "")
    hoten = st.session_state.get("sv_hoten", "")
    class_code = st.session_state.get("sv_class", "").strip()
    n = len(df)

    # Tr∆∞·ªõc khi cho l√†m, ki·ªÉm tra ƒë√£ n·ªôp MCQ l·ªõp n√†y ch∆∞a
    ws = open_mcq_response_ws_for_class(class_code, n)
    header = ws.row_values(1)
    if attempt_exists(ws, header, mssv):
        st.error("B·∫°n ƒë√£ n·ªôp MCQ tr∆∞·ªõc ƒë√≥. Ch·ªâ ƒë∆∞·ª£c l√†m 1 l·∫ßn.")
        return

    # Sinh tr·∫≠t t·ª± c√¢u theo SV
    order = stable_perm(n, f"MCQ_ORDER|{QUIZ_ID}|{mssv}|{hoten}")
    st.success(f"ƒê·ªÅ MCQ {QUIZ_ID} ‚Äî {n} c√¢u (4 ƒë√°p √°n).")

    cur = st.session_state.get("mcq_cursor", 0)
    cur = max(0, min(cur, n-1))
    st.session_state["mcq_cursor"] = cur

    row = df.iloc[order[cur]]
    qidx = int(row["q_index"])
    qtext = str(row["question"])
    options = [str(row["optionA"]), str(row["optionB"]), str(row["optionC"]), str(row["optionD"])]

    st.markdown(f"### C√¢u {cur+1}/{n}")
    st.write(qtext)

    perm = _option_perm_for_student(mssv, qidx)
    shuffled_opts = [options[i] for i in perm]
    labels = ['A', 'B', 'C', 'D']
    # map nh√£n hi·ªÉn th·ªã -> nh√£n g·ªëc
    inv = {labels[i]: ['A','B','C','D'][perm[i]] for i in range(4)}

    current = st.session_state["mcq_answers"].get(qidx, None)
    # Kh√¥ng pre-select ƒë·ªÉ tr√°nh ph·ª©c t·∫°p; SV c√≥ th·ªÉ xem l·∫°i ƒë∆∞·ª£c.
    pick = st.radio(
        "Ch·ªçn ƒë√°p √°n:",
        options=[f"{labels[i]}. {shuffled_opts[i]}" for i in range(4)],
        index=None,
        key=f"mcq_{qidx}",
    )
    if pick:
        chosen_label = pick.split('.', 1)[0].strip()
        st.session_state["mcq_answers"][qidx] = inv[chosen_label]

    c1, c2, c3, c4 = st.columns([1,1,1,1])
    with c1:
        if st.button("‚¨ÖÔ∏è C√¢u tr∆∞·ªõc", use_container_width=True, disabled=(cur==0)):
            st.session_state["mcq_cursor"] = max(0, cur-1); st.rerun()
    with c2:
        if st.button("‚û°Ô∏è C√¢u sau", use_container_width=True, disabled=(cur==n-1)):
            st.session_state["mcq_cursor"] = min(n-1, cur+1); st.rerun()
    with c3:
        if st.button("üßπ X√≥a ch·ªçn", use_container_width=True):
            if qidx in st.session_state["mcq_answers"]:
                del st.session_state["mcq_answers"][qidx]; st.rerun()
    with c4:
        if st.button("üìù N·ªôp MCQ", use_container_width=True, type="primary"):
            total_correct = 0
            ans = st.session_state["mcq_answers"]
            for _, r in df.iterrows():
                qi = int(r["q_index"])
                if ans.get(qi, "") == str(r["correct"]).strip().upper():
                    total_correct += 1
            try:
                upsert_mcq_response(mssv, hoten, ans, total_correct, n)
                st.success(f"‚úÖ ƒê√£ n·ªôp MCQ. ƒêi·ªÉm: {total_correct}/{n}")
                for k in ["mcq_cursor", "mcq_answers"]:
                    st.session_state.pop(k, None)
            except Exception as e:
                st.error(f"L·ªói ghi MCQ_Responses: {e}")

def upsert_mcq_response(mssv: str, hoten: str, answers: dict, total_correct: int, n_questions: int):
    """
    Ghi MCQ v√†o sheet 'MCQ<CLASS>' v√† ch·∫∑n l√†m l·∫°i.
    """
    class_code = st.session_state.get("sv_class", "").strip()
    ws = open_mcq_response_ws_for_class(class_code, n_questions)
    header = ws.row_values(1)

    if attempt_exists(ws, header, mssv):
        st.error("B·∫°n ƒë√£ n·ªôp MCQ tr∆∞·ªõc ƒë√≥. Ch·ªâ ƒë∆∞·ª£c l√†m 1 l·∫ßn.")
        return

    rows = ws.get_all_values()[1:]
    col_mssv = header.index("MSSV") if "MSSV" in header else 1
    found_row = None
    for idx, r in enumerate(rows, start=2):
        if len(r) > col_mssv and r[col_mssv].strip() == mssv.strip():
            found_row = idx
            break
    if not found_row:
        found_row = len(rows) + 2
        for col_name, value in {"MSSV": mssv, "H·ªç v√† T√™n": hoten, "class": class_code}.items():
            if col_name in header:
                cidx = header.index(col_name) + 1
                ws.update_acell(f"{_col_idx_to_letter(cidx)}{found_row}", value)
        info = load_whitelist_students_by_class(class_code).get(mssv, {})
        for col_name, key in {"NTNS": "dob", "t·ªï": "to"}.items():
            if col_name in header and key in info and info[key]:
                cidx = header.index(col_name) + 1
                ws.update_acell(f"{_col_idx_to_letter(cidx)}{found_row}", info[key])

    updates = []
    for q in range(1, n_questions + 1):
        if str(q) in header:
            cidx = header.index(str(q)) + 1
            updates.append({"range": f"{_col_idx_to_letter(cidx)}{found_row}", "values": [[answers.get(q, "")]]})
    for col_name, value in {
        "score": total_correct,
        "submitted_at": datetime.now().astimezone().isoformat(timespec="seconds"),
        "quiz_id": QUIZ_ID,
        "class": class_code
    }.items():
        if col_name in header:
            cidx = header.index(col_name) + 1
            updates.append({"range": f"{_col_idx_to_letter(cidx)}{found_row}", "values": [[value]]})

    if updates:
        ws.batch_update(updates)

# =========================
# TEACHER PANEL
# =========================
def teacher_login() -> bool:
    st.subheader("ƒêƒÉng nh·∫≠p Gi·∫£ng vi√™n")

    if st.session_state.get("is_teacher", False):
        st.success("ƒê√£ ƒëƒÉng nh·∫≠p.")
        # N√∫t ƒëƒÉng xu·∫•t GV (lu√¥n hi·ªán khi ƒë√£ ƒëƒÉng nh·∫≠p)
        if st.button("üö™ ƒêƒÉng xu·∫•t GV", type="secondary"):
            st.session_state["is_teacher"] = False
            st.success("ƒê√£ ƒëƒÉng xu·∫•t.")
            st.rerun()
        return True

    with st.form("teacher_login_form"):
        u = st.text_input("T√†i kho·∫£n", value="", placeholder="teacher")
        p = st.text_input("M·∫≠t kh·∫©u", value="", placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢", type="password")
        ok = st.form_submit_button("ƒêƒÉng nh·∫≠p")

    if ok:
        if u.strip() == TEACHER_USER and p.strip() == TEACHER_PASS:
            st.session_state["is_teacher"] = True
            st.success("ƒêƒÉng nh·∫≠p th√†nh c√¥ng.")
            st.rerun()
        else:
            st.error("Sai t√†i kho·∫£n ho·∫∑c m·∫≠t kh·∫©u.")
    return False

def _diagnose_questions():
    st.markdown("#### üîé Ki·ªÉm tra Question sheet")
    try:
        gc = get_gspread_client()
        sh = gc.open_by_key(QUESTIONS_SPREADSHEET_ID)
        ws_titles = [w.title for w in sh.worksheets()]
        st.success("‚úÖ M·ªü ƒë∆∞·ª£c file c√¢u h·ªèi.")
        st.write("Worksheets:", ws_titles)
        if QUESTIONS_SHEET_NAME in ws_titles:
            st.info(f"Worksheet hi·ªán h√†nh: **{QUESTIONS_SHEET_NAME}** ‚úì")
        else:
            st.error(f"‚ùå Kh√¥ng th·∫•y worksheet: **{QUESTIONS_SHEET_NAME}**")
    except Exception as e:
        st.error(f"Kh√¥ng m·ªü ƒë∆∞·ª£c file c√¢u h·ªèi: {e}")

def _view_questions():
    st.markdown("#### üìã Ng√¢n h√†ng c√¢u h·ªèi Likert hi·ªán t·∫°i")
    dfq = load_questions_df()
    if dfq.empty:
        st.warning("Worksheet **Question** ƒëang tr·ªëng.")
    else:
        st.dataframe(dfq, use_container_width=True, height=420)
        st.caption(f"T·ªïng s·ªë c√¢u: **{len(dfq)}**")
    with st.expander("üîé Ch·∫©n ƒëo√°n"):
        _diagnose_questions()

def push_questions(df: pd.DataFrame):
    """
    Ghi ƒê√à to√†n b·ªô worksheet c√¢u h·ªèi Likert b·∫±ng dataframe cung c·∫•p.
    C·∫ßn c·ªôt t·ªëi thi·ªÉu: q_index, question.
    """
    required = {"q_index", "question"}
    if not required.issubset(set(df.columns)):
        missing = ", ".join(sorted(required - set(df.columns)))
        st.error(f"Thi·∫øu c·ªôt b·∫Øt bu·ªôc: {missing}")
        return

    if "q_index" in df.columns:
        df["q_index"] = pd.to_numeric(df["q_index"], errors="coerce").astype("Int64")

    if "quiz_id" not in df.columns:
        df["quiz_id"] = QUIZ_ID
    else:
        df["quiz_id"] = df["quiz_id"].fillna(QUIZ_ID)

    columns_order = ["quiz_id", "q_index", "facet", "question", "left_label", "right_label", "reverse"]
    for c in columns_order:
        if c not in df.columns:
            df[c] = ""
    df = df[columns_order].sort_values(["quiz_id", "q_index"], na_position="last")

    gc = get_gspread_client()
    try:
        sh = gc.open_by_key(QUESTIONS_SPREADSHEET_ID)
    except Exception as e:
        st.error(f"Kh√¥ng m·ªü ƒë∆∞·ª£c file c√¢u h·ªèi: {e}")
        return

    try:
        try:
            ws = sh.worksheet(QUESTIONS_SHEET_NAME)
            ws.clear()
        except gspread.WorksheetNotFound:
            ws = sh.add_worksheet(title=QUESTIONS_SHEET_NAME, rows=2000, cols=20)

        ws.append_row(list(df.columns))
        if len(df) > 0:
            ws.append_rows(df.astype(object).values.tolist())

        load_questions_df.clear()
        st.success(f"‚úÖ ƒê√£ ghi {len(df)} d√≤ng v√†o **{QUESTIONS_SHEET_NAME}**.")
    except Exception as e:
        st.error(f"L·ªói ghi d·ªØ li·ªáu l√™n sheet: {e}")

def _upload_questions():
    st.markdown("#### üì• T·∫£i c√¢u h·ªèi Likert (CSV/XLSX)")
    st.info(
        "File n√™n c√≥ c·ªôt: quiz_id | q_index | facet | question | left_label | right_label | reverse. "
        "T·ªëi thi·ªÉu b·∫Øt bu·ªôc: q_index, question. N·∫øu thi·∫øu quiz_id, h·ªá th·ªëng s·∫Ω ƒëi·ªÅn m·∫∑c ƒë·ªãnh."
    )
    up = st.file_uploader("Ch·ªçn file c√¢u h·ªèi", type=["csv", "xlsx"])

    if up is not None:
        try:
            if up.name.lower().endswith(".csv"):
                df_new = pd.read_csv(up)
            else:
                import openpyxl
                df_new = pd.read_excel(up)
        except Exception as e:
            st.error(f"Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c file: {e}")
            return

        st.write("Xem nhanh d·ªØ li·ªáu t·∫£i l√™n:")
        st.dataframe(df_new.head(10), use_container_width=True)
        if st.button("Ghi l√™n Question", type="primary"):
            push_questions(df_new)

    with st.expander("üîé Ch·∫©n ƒëo√°n"):
        _diagnose_questions()

def _diagnose_responses():
    st.markdown("#### ‚ÑπÔ∏è Ghi ch√∫ Responses")
    st.info(
        "K·∫øt qu·∫£ ƒë∆∞·ª£c ghi theo t·ª´ng l·ªõp:\n"
        "- Likert: LikertD25A, LikertD25C\n"
        "- MCQ: MCQD25A, MCQD25C\n"
        "Danh s√°ch l·ªõp g·ªëc (whitelist): D25A, D25C."
    )

def _view_responses():
    _diagnose_responses()

def teacher_panel():
    """UI ch√≠nh c·ªßa tab Gi·∫£ng vi√™n."""
    
    # N√∫t ƒëƒÉng xu·∫•t GV n·∫øu ƒë√£ ƒëƒÉng nh·∫≠p
    if st.session_state.get("is_teacher", False):
        if st.button("üö™ ƒêƒÉng xu·∫•t GV", type="secondary"):
            st.session_state["is_teacher"] = False
            st.success("ƒê√£ ƒëƒÉng xu·∫•t.")
            st.rerun()

    if not teacher_login():
        return

    tab1, tab2, tab3 = st.tabs(["üìã Xem c√¢u h·ªèi Likert", "üì• T·∫£i c√¢u h·ªèi Likert", "üìë Ghi ch√∫ Responses"])
    with tab1:
        _view_questions()
    with tab2:
        _upload_questions()
    with tab3:
        _view_responses()

# =========================
# SIDEBAR NAVIGATION
# =========================
st.sidebar.header("Ch·ª©c nƒÉng")
page = st.sidebar.radio("ƒêi ƒë·∫øn", ["Sinh vi√™n", "Gi·∫£ng vi√™n", "H∆∞·ªõng d·∫´n"], index=0)

if page == "Sinh vi√™n":
    render_banner()
    st.title("Sinh vi√™n l√†m b√†i")

    # N√∫t ƒêƒÉng xu·∫•t SV
    if st.session_state.get("sv_allow") or st.session_state.get("sv_started") or st.session_state.get("mcq_answers"):
        if st.button("üö™ ƒêƒÉng xu·∫•t", type="secondary"):
            for k in list(st.session_state.keys()):
                if k.startswith("sv_") or k.startswith("mcq_"):
                    st.session_state.pop(k, None)
            st.success("ƒê√£ ƒëƒÉng xu·∫•t.")
            st.stop()

    # C·ªïng ƒëƒÉng nh·∫≠p d√πng chung
    if not student_gate():
        st.stop()

    # ƒêƒÉng nh·∫≠p OK ‚Üí ch·ªçn mode
    mode = st.radio("Ch·ªçn lo·∫°i tr·∫Øc nghi·ªám:", ["Likert 36", "MCQ 4 ƒë√°p √°n"], horizontal=True)

    if mode == "Likert 36":
        likert36_exam()
    else:
        mcq_exam()

elif page == "Gi·∫£ng vi√™n":
    render_banner()
  
    teacher_panel()

else:
    render_banner()
    st.title("H∆∞·ªõng d·∫´n nhanh")
    st.markdown(
        "- **Sinh vi√™n:** ƒëƒÉng nh·∫≠p (L·ªõp + MSSV + H·ªç & T√™n) ‚Üí ch·ªçn **Likert 36** ho·∫∑c **MCQ 4 ƒë√°p √°n** ‚Üí l√†m b√†i ‚Üí **N·ªôp b√†i**.  \n"
        "  M·ªói lo·∫°i b√†i ch·ªâ **l√†m 1 l·∫ßn**. Likert c√≥ **ƒë·ªìng h·ªì ƒë·∫øm ng∆∞·ª£c** theo `TIME_LIMIT_MIN`.\n"
        "- **Gi·∫£ng vi√™n:** xem/t·∫£i ng√¢n h√†ng Likert; k·∫øt qu·∫£ ƒë∆∞·ª£c ghi theo l·ªõp: `Likert<CLASS>`, `MCQ<CLASS>`.  \n"
        "- **Google Sheets:**\n"
        "  - `Question`: ng√¢n h√†ng Likert (`quiz_id | q_index | facet | question | left_label | right_label | reverse`)\n"
        "  - `D25A`, `D25C`: roster g·ªëc (`STT | MSSV | H·ªç v√† t√™n | NTNS | t·ªï`)\n"
        "  - `LikertD25A`, `LikertD25C`, `MCQD25A`, `MCQD25C`: k·∫øt qu·∫£ theo l·ªõp.\n"
        "- N·∫øu l·ªói quy·ªÅn, h√£y **Share** file cho service account trong secrets, quy·ªÅn **Editor**."
    )

st.markdown("---")
st.markdown("¬© B·∫£n quy·ªÅn thu·ªôc v·ªÅ TS. ƒê√†o H·ªìng Nam - ƒê·∫°i h·ªçc Y D∆∞·ª£c Th√†nh ph·ªë H·ªì Ch√≠ Minh.")
